<!DOCTYPE html>
<head>
  <title>Ali Lyons Blog</title>
  <meta charset="UTF-8">
<link rel="stylesheet" type="text/css" href="blog-posts-stylesheet.css">
</head>

<main>
  <h1>Ruby Clases</h1>
  <!-- <h2>The subtitle, if you want it</h2> -->
  <h4>08/31/2015</h4>

  <section>
    <p>
    Ruby classes allow for grouping a set of methods so they can be shared by similar 
    objects. 
    </p>
    <p>
    As an example, let's say you own a shop called Widget Mania selling... widgets. 
    You need a way to standardize widget pricing to cut down on time. Every 
    single widget in the store will need: 

     <li>5 digit widget code</li>
     <li>price</li>

    Instead of having to write these methods each time you create a widget, you can 
    create a widget class with these three methods. Each time you create a widget object from the widget class,
    the widget class methods are automatically available to the widget object.  
    </p>
    <p>
    Here is the code for creating our Widget class and its initialization method and instance variables: 

    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">Widget</span>
  
  <span style="color: #008800; font-weight: bold">def</span> <span style="color: #0066BB; font-weight: bold">initialize</span>(code, price)
    <span style="color: #3333BB">@code</span> <span style="color: #333333">=</span> code  
    <span style="color: #3333BB">@price</span> <span style="color: #333333">=</span> price
  <span style="color: #008800; font-weight: bold">end</span>

<span style="color: #008800; font-weight: bold">end</span>
</pre></div>


    <p>
    Our newly minted Widget class takes 2 arguments, code and price. Its initialize method creates 2 instance variables (instance variables 
    start with an @symbol), that will be available throughout the class, not just within the initialize method. In other words, the instance methods are 
    scoped to the entire class unlike a local variable which is scoped only to its method and disappears once the method has run. Variable scoping within classes is a major advantage to using classes and why they are so efficient. Also important to note in terms of syntax is that classes are named with
    CamelCase and always include the keyword end. 
    </p>
    <p>
    Now that we've got our class created, let's welcome some baby widgets into this world! The following code instantiates a new widget object called with the uninspired name of widget_1:

    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">widget_1 <span style="color: #333333">=</span> <span style="color: #003366; font-weight: bold">Widget</span><span style="color: #333333">.</span>new(<span style="color: #0000DD; font-weight: bold">12345</span>,<span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">.</span><span style="color: #0000DD; font-weight: bold">99</span>)
</pre></div></p>
     <p>
     New objects are created by calling new on the class (with a . of course). We passed two arguments: the extremely tidy and unlikely five digit code
     of 12345 and a cheapo price of 1.99. 
     </p>
     <p>
     There's no end to the methods we can dream up for our baby widget objects. We can create a method that adds the $ to our price, generate a standardized UPC code, sort them, group them and on and on. If we have some outlier widgets that take exception to our class methods, we
     can accommodate for that, too, but this gets into inheritance, which is another juicy topic for another day. 

     </p>


  </section>
</main>

