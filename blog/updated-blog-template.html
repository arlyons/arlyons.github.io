<!DOCTYPE html>
<head>
  <title>Ali Lyons Blog</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="blog-posts-stylesheet.css">
</head>

<main>
<div class="container">
  <h1>JavaScript vs Ruby</h1>
  <!-- <h2>The subtitle, if you want it</h2> -->
  <h4>10/1/2015</h4>

  <section>
    <p>
      As a beginner, it's hard to wrap your head around fundamental differences in the way programming languages are designed. 
      Switching between them can feel a bit like visiting another planet where your basic concepts don't exist
      or are turned completely upside down like Bizzaro World. 
    </p>
    <p><img src="bizarrocode.png"></p>
    <p>
      Here is a <a href="https://docs.google.com/spreadsheets/d/1UFti9xL-Jau94TbQcyUUVaWtgYWC891dF-g6kXkVg-0/pubhtml"><u>running tab</u></a> of differences between Ruby and JavaScript that I'll (hopefully) be adding to over the next few months. 
    </p>
  
    <p></p>
    <h4>Methods in Ruby and JavaScript</h4>
    <p>
      One big difference that tripped me up quite a bit when switching from Ruby to JavaScript was the difference in how 
      each handles methods. In Ruby, the terms method and function are interchangeable while in JavaScript a method is more strictly
      defined as a function <em>created inside an object</em>. Since everything in Ruby is an object, each method that you create, is <em>automatically assigned to the Object class,</em> whereas JavaScript can and does frequently have "free-standing" blocks of code. 
    <p>
      One of the first things beginning programmers learn is how to work with built-in methods. But it's easy to miss the fact 
      that these methods are really just functions tied to particular objects, and will only work on those specific objects. 
      For example, Ruby's #reverse method is defined within the String class and can only be called on other string objects.
      JavaScript also has built-in methods which are tied to its global objects (Array, String, Object, etc.) and although there are slight
      differences in syntax, Ruby and JS share many built-in methods. 
    </p>
    <p>
      To see the difference, first let's create a Ruby method. Below we have a very bare bones method (a.k.a. function) that takes one argument:

      <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">def</span> <span style="color: #0066BB; font-weight: bold">greeting</span>(<span style="color: #007020">name</span>)
  <span style="color: #007020">puts</span> <span style="background-color: #fff0f0">&quot;Howdy </span><span style="background-color: #eeeeee">#{</span><span style="color: #007020">name</span><span style="background-color: #eeeeee">}</span><span style="background-color: #fff0f0">!&quot;</span>
<span style="color: #008800; font-weight: bold">end</span>

greeting(<span style="background-color: #fff0f0">&quot;Ali&quot;</span>)
</pre></div>
<p>
     Output:
  <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">Howdy Ali!
</pre></div>
<p>
  Here is the same program as a JavaScript function, returning the same output:

  <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">var</span> greeting <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">function</span>(name){
    console.log(<span style="background-color: #fff0f0">&quot;Howdy &quot;</span> <span style="color: #333333">+</span> name);
    greeting
};

greeting(<span style="background-color: #fff0f0">&quot;Ali&quot;</span>);
</pre></div>
</p> 
</p>
</p>
</p>
<p>
  The above examples look pretty similar. But once objects are in the picture, they take on a lot more similarities, although it's easy to 
  miss sometimes due to Ruby's implicitly assigning all methods to the object class. Here is the same bare bones example, with a twist. First 
  Ruby: 
</p>
<p>
  <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">Name</span>
    <span style="color: #008800; font-weight: bold">def</span> <span style="color: #0066BB; font-weight: bold">initialize</span>(<span style="color: #007020">name</span>)
        <span style="color: #3333BB">@name</span> <span style="color: #333333">=</span> <span style="color: #007020">name</span>
    <span style="color: #008800; font-weight: bold">end</span>
  
    <span style="color: #008800; font-weight: bold">def</span> <span style="color: #0066BB; font-weight: bold">greeting</span>
       <span style="color: #007020">puts</span> <span style="background-color: #fff0f0">&quot;Howdy </span><span style="background-color: #eeeeee">#{</span><span style="color: #3333BB">@name</span><span style="background-color: #eeeeee">}</span><span style="background-color: #fff0f0">!&quot;</span> 
    <span style="color: #008800; font-weight: bold">end</span>

<span style="color: #008800; font-weight: bold">end</span>

new_object <span style="color: #333333">=</span> <span style="color: #003366; font-weight: bold">Name</span><span style="color: #333333">.</span>new(<span style="background-color: #fff0f0">&quot;Ali&quot;</span>)
new_object<span style="color: #333333">.</span>greeting
</pre></div>

</p>
<p>
  Above we've created our very own Ruby object: <strong>new_object</strong> which is an instance of our class <strong>Name</strong>. Much like the built-in Ruby methods, we now can use <strong>dot notation</strong> to call this method. The reason I say 
  this is a bit confusing is because every method call in Ruby is on an object, but that object might be hidden. The puts method is acting on the 
  implicit object we happen to be in at the time. Math operators are also methods that act on objects and could also be written using dot notation: 
  2.+2

</p>
<p>
  So now that we know that, despite appearances, Ruby methods are always called <strong>on</strong> an object and how to use dot notation to call methods on Ruby objects, let's take another look a proper JavaScript method, which you'll recall from above is a function created inside an object.
</p>
<p>
<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">var</span> person <span style="color: #333333">=</span> {
    name<span style="color: #333333">:</span> <span style="background-color: #fff0f0">&quot;Ali&quot;</span>
}

<span style="color: #008800; font-weight: bold">var</span> greeting <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">function</span>(){
    console.log(<span style="background-color: #fff0f0">&quot;Howdy &quot;</span> <span style="color: #333333">+</span> person.name);
};

greeting();

end
</pre></div>


</p>
<p>
Above we've created a JavaScript object, <strong>person</strong>, with a property of <strong>name</strong> and a value of <strong>"Ali"</strong>. Now that we have a proper object, this is starting to feel a little more akin to Ruby and we can make use of our familiar dot notation again by calling <strong>.name</strong> on the <strong>person</strong> object. 
</p>
    <h4>JavaScript's Lexical Scoping</h4>
    <p>
      JavaScript is extremely liberal in terms of scoping. In the following example, all variables are visible and available for use
      by the entire program, simply because the second and third functions are nested within the first.
    </p>
    <p>
      <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">var</span> allEncompassingFunction <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">function</span>(){
    <span style="color: #008800; font-weight: bold">var</span> output <span style="color: #333333">=</span> <span style="background-color: #fff0f0">&quot;&quot;</span>;
    <span style="color: #008800; font-weight: bold">var</span> nestedFunction1 <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">function</span>(){
    output <span style="color: #333333">+=</span> <span style="background-color: #fff0f0">&quot;I have access to the result from inside nestedFunction1! &quot;</span>;
};
  <span style="color: #008800; font-weight: bold">var</span> nestedFunction2 <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">function</span>(){
      output <span style="color: #333333">+=</span> <span style="background-color: #fff0f0">&quot; As do I in nestedFunction2!&quot;</span>;
  };
  nestedFunction1();
  nestedFunction2();
  <span style="color: #008800; font-weight: bold">return</span> output;
};

console.log(allEncompassingFunction());
</pre></div>

<p>
Here is what's returned to the console: 

  <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">I have access to the result from inside nestedFunction1!  As do I in nestedFunction2!
</pre></div>
</p>
    </p>
  <p>
   Pretty scary stuff. It's particularly important to pay attention to encapsulation in JavaScript otherwise you'll have global variables wreaking
   havoc all over the place. 
  </p>

  <p>
    Ruby on the other hand, has much more stringent rules for scoping. Here is how we would perform a similar concatenation exercise accessing varialbes across methods in Ruby via instance variables:
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">StringJoiner</span>
  
  <span style="color: #008800; font-weight: bold">def</span> <span style="color: #0066BB; font-weight: bold">initialize</span>(string1, string2)
    <span style="color: #3333BB">@string1</span> <span style="color: #333333">=</span> string1 
    <span style="color: #3333BB">@string2</span> <span style="color: #333333">=</span> string2
  <span style="color: #008800; font-weight: bold">end</span>
  
  <span style="color: #008800; font-weight: bold">def</span> <span style="color: #0066BB; font-weight: bold">join</span>
      <span style="color: #007020">p</span> <span style="background-color: #fff0f0">&quot;</span><span style="background-color: #eeeeee">#{</span><span style="color: #3333BB">@string1</span><span style="background-color: #eeeeee">}#{</span><span style="color: #3333BB">@string2</span><span style="background-color: #eeeeee">}</span><span style="background-color: #fff0f0">&quot;</span>
  <span style="color: #008800; font-weight: bold">end</span>
      
<span style="color: #008800; font-weight: bold">end</span>

sentence <span style="color: #333333">=</span> <span style="color: #003366; font-weight: bold">StringJoiner</span><span style="color: #333333">.</span>new(<span style="background-color: #fff0f0">&quot;I&#39;m the first string!&quot;</span>, <span style="background-color: #fff0f0">&quot; And I&#39;m the second one!&quot;</span>)
sentence<span style="color: #333333">.</span>join
</pre></div>
<p>
  Here is the output: 
  <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">&quot;I&#39;m the first string! And I&#39;m the second one!&quot;
</pre></div>

</p>
  </p>
  <p>
  Quite a bit more effort has to go into allowing the variables to be accessible by other methods within our class in Ruby. This makes encapsulation
  a bit easier and doesn't allow for accidental global variable creation quite so easily. Ruby also makes a distinction between reader and writer attributes for its variables, which is another safeguard against variables being accidental reassigned elsewhere in the program. 
  </p>

  </section>
</main>


